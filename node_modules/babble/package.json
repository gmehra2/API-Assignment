{
  "_args": [
    [
      {
        "raw": "babble",
        "scope": null,
        "escapedName": "babble",
        "name": "babble",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "D:\\LLyods\\API Assignment"
    ]
  ],
  "_from": "babble@latest",
  "_id": "babble@0.11.0",
  "_inCache": true,
  "_location": "/babble",
  "_nodeVersion": "5.6.0",
  "_npmOperationalInternal": {
    "host": "packages-9-west.internal.npmjs.com",
    "tmp": "tmp/babble-0.11.0.tgz_1455628060053_0.407007442554459"
  },
  "_npmUser": {
    "name": "josdejong",
    "email": "wjosdejong@gmail.com"
  },
  "_npmVersion": "3.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "babble",
    "scope": null,
    "escapedName": "babble",
    "name": "babble",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/babble/-/babble-0.11.0.tgz",
  "_shasum": "62f78ea5fcc0c96d6346af64359acb62ba00542d",
  "_shrinkwrap": null,
  "_spec": "babble",
  "_where": "D:\\LLyods\\API Assignment",
  "author": {
    "name": "Jos de Jong",
    "email": "wjosdejong@gmail.com",
    "url": "https://github.com/josdejong"
  },
  "bugs": {
    "url": "https://github.com/josdejong/babble/issues"
  },
  "dependencies": {
    "es6-promise": "^3.1.2",
    "node-uuid": "~1.4.7",
    "pubnub": "~3.9.2",
    "pubsub-js": "~1.5.3"
  },
  "description": "Dynamic communication flows between message based actors.",
  "devDependencies": {
    "browserify": "latest",
    "mocha": "latest",
    "uglify-js": "latest"
  },
  "directories": {},
  "dist": {
    "shasum": "62f78ea5fcc0c96d6346af64359acb62ba00542d",
    "tarball": "https://registry.npmjs.org/babble/-/babble-0.11.0.tgz"
  },
  "gitHead": "6b7e84d7fb0df2d1129f0646b37a9d89d3da2539",
  "homepage": "https://github.com/josdejong/babble#readme",
  "keywords": [
    "pubsub",
    "conversation",
    "talk"
  ],
  "main": "./index.js",
  "maintainers": [
    {
      "name": "josdejong",
      "email": "wjosdejong@gmail.com"
    }
  ],
  "name": "babble",
  "optionalDependencies": {},
  "readme": "# Babble\n\nDynamic communication flows between message based actors.\n\nBabble makes it easy to code communication flows between actors. A conversation\nis modeled as a control flow diagram containing blocks `ask`, `tell`, `listen`,\n`iif`, `decide`, and `then`. Each block can link to a next block in the\ncontrol flow. Conversations are dynamic: a scenario is build programmatically,\nand the blocks can dynamically determine the next block in the scenario.\nDuring a conversation, a context is available to store the state of the\nconversation.\n\nBabblers communicate with each other via a message bus. Babble comes with \nbuilt in support for a local message bus, and [pubnub](http://www.pubnub.com/) \nto connect actors distributed over multiple devices. Its easy to add support\nfor other message buses.\n\nBabble runs in node.js and in the browser.\n\n\n## Usage\n\nInstall babble via npm:\n\n    npm install babble\n\nLoad in node.js:\n\n```js\nvar babble = require('babble');\n```\n\nLoad in the browser:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <!-- load pubnub, only needed when using pubnub -->\n  <script src=\"http://cdnjs.cloudflare.com/ajax/libs/pubnub/3.5.4/pubnub.min.js\"></script>\n\n  <!-- load babble -->\n  <script src=\"../../dist/babble.min.js\"></script>\n</head>\n<body>\n</body>\n</html>\n```\n\nThen, babble can be loaded and used:\n\n```js\n\nvar babble = require('babble');\n\nvar emma = babble.babbler('emma');\nvar jack = babble.babbler('jack');\n\n// listen for messages containing either 'age' or 'how old'\nemma.listen(/age|how old/)\n    .tell(function () {\n      return 25;\n    });\n\njack.ask('emma', 'what is your age?', function (age, context) {\n  console.log(context.from + ' is ' + age + ' years old');\n});\n```\n\n## Control flow\n\nTODO: describe control flow blocks\n\n\n## Examples\n\n### Say hi\n\nBabble can be used to listen for messages and send a reply. In the following\nexample, emma listens for a message \"hi\", then she will listen to the next\nmessage. Depending on the contents of this second message, she determines how\nto respond. Jack says hi to emma, then tells his name or age, and awaits a\nresponse from emma.\n\nThis scenario can be represented by the following control flow diagram:\n\n![say hi](https://raw.github.com/enmasseio/babble/master/img/say_hi.png)\n\nThe scenario can be programmed as:\n\n```js\nvar babble = require('babble');\n\nvar emma = babble.babbler('emma');\nvar jack = babble.babbler('jack');\n\nemma.listen('hi')\n    .listen(function (message, context) {\n      console.log(context.from + ': ' + message);\n      return message;\n    })\n    .decide(function (message, context) {\n      return (message.indexOf('age') != -1) ? 'age' : 'name';\n    }, {\n      'name': babble.tell('hi, my name is emma'),\n      'age':  babble.tell('hi, my age is 27')\n    });\n\njack.tell('emma', 'hi')\n    .tell(function (message, context) {\n      if (Math.random() > 0.5) {\n        return 'my name is jack'\n      } else {\n        return 'my age is 25';\n      }\n    })\n    .listen(function (message, context) {\n      console.log(context.from + ': ' + message);\n    });\n```\n\n### Plan a meeting\n\nThe following scenario describes two peers planning a meeting in two steps:\nFirst jack asks whether emma has time for a meeting, and if so, jack will\npropose to meet, and await emma's response.\n\nThis scenario can be represented by the following control flow diagram:\n\n![plan a meeting](https://raw.github.com/enmasseio/babble/master/img/plan_a_meeting.png)\n\nThe scenario can be coded as follows. Note that the implementations of the\ncontrol flow blocks are separated from the flow itself.\n\n```js\nvar babble = require('babble');\n\nvar emma = babble.babbler('emma');\nvar jack = babble.babbler('jack');\n\nfunction decideIfAvailable () {\n  return (Math.random() > 0.4) ? 'yes' : 'no';\n}\n\nfunction decideToAgree (response) {\n  if (response == 'can we meet at 15:00?' && Math.random() > 0.5) {\n    return 'ok';\n  }\n  else {\n    return 'no';\n  }\n}\n\nemma.listen('do you have time today?')\n    .decide(decideIfAvailable, {\n      yes: babble.tell('yes')\n              .listen()\n              .decide(decideToAgree, {\n                ok: babble.tell('ok'),\n                no: babble.tell('no')\n              }),\n      no: babble.tell('no')\n    });\n\nfunction noTime () {\n  console.log('emma has no time');\n}\n\nfunction agreesToMeet (response) {\n  return (response == 'ok') ? 'ok': 'no';\n}\n\nfunction agreement () {\n  console.log('emma agreed');\n}\n\nfunction noAgreement () {\n  console.log('emma didn\\'t agree');\n}\n\njack.ask('emma', 'do you have time today?')\n    .decide({\n      yes: babble.tell('can we meet at 15:00?')\n              .listen()\n              .decide(agreesToMeet, {\n                ok: babble.then(agreement),\n                no: babble.then(noAgreement)\n              }),\n      no: babble.then(noTime)\n    });\n```\n\n\n## API\n\nBabble has the following factory functions:\n\n- `babble.ask(message: String | Function [, callback: Function]) : Block`  \n  Send a question and listen for a reply. \n  This is equivalent of doing `tell(message).listen([callback])`.\n\n- `babble.babbler(id: String) : Babbler`  \n  Factory function to create a new Babbler.\n\n- `babble.babblify(actor: Object, params: Object) : Object`  \n  Babblify an actor. The babblified actor will be extended with functions\n  `ask`, `tell`, `listen`, and `listenOnce`.\n \n  Babble expects that messages sent via `actor.send(to, message)` will be \n  delivered by the recipient on a function `actor.receive(from, message)`.\n  Babble replaces the original `receive` with a new one, which is used to\n  listen for all incoming messages. Messages ignored by babble are propagated\n  to the original `receive` function.\n \n  The function accepts the following parameters:\n  \n  - `actor: Object`  \n    The actor to be babblified. Must be an Object containing functions \n    `send(to, message)` and `receive(from, message)`.\n  - `[params: Object]`  \n    Optional parameters. Can contain properties:\n    \n      - `id: string`\n        The id for the babbler\n      - `send: string`\n        The name of an alternative send function available on the actor.\n      - `receive: string`\n        The name of an alternative receive function available on the actor.\n\n  The function returns the babblified actor. A babblified actor can be restored \n  in its original state using `unbabblify(actor)`.\n\n- `babble.decide([decision: Function, ] choices: Object<String, Block>) : Block`  \n  Create a flow starting with a `Decision` block.\n  When a `decision` function is provided, the function is invoked as\n  `decision(response, context)`. The function must return the id for the next\n  block in the control flow, which must be available in the provided `options`.\n  The function `decision` can also return a Promise resolving with an id for the \n  next block. When `decision` is not provided, the next block will be mapped \n  directly from the `response`, which should be a string in that case. \n  \n  Parameter `choices` is a map with the possible next blocks in the flow. \n  The next block is selected by the id returned by the `decision` function.\n  The returned block is used as next block in the control flow.\n\n  When there is no matching choice, the choice `'default'` will be selected\n  when available.\n\n- `babble.iif(condition: function | RegExp | * [, trueBlock : Block] [, falseBlock : Block]) : Block`  \n  Create a control flow starting with an `IIf` block.\n  When the condition is a function, it can either return a boolean or a Promise\n  resolving with a boolean value.\n  When the condition evaluates `true`, `trueBlock` is executed. If no `trueBlock`\n  is provided, the next block in the chain will be executed.\n  When the condition evaluates `true`, `falseBlock` is executed.\n\n- `babble.listen([callback: Function])`  \n  Wait for a message. The provided callback function is called as \n  `callback(response, context)`, where `response` is the just received message.\n  When the callback returns a promise, babble will wait with execution of the \n  next block until the promise is resolved. The result returned by the callback\n  is passed to the next block in the chain.\n  Providing a callback function is equivalent of doing \n  `babble.listen().then(callback)`.\n\n- `babble.tell(message: Function | *) : Block`  \n  Create a flow starting with a `Tell` block. Message can be a static value,\n  or a callback function returning a message dynamically. The callback function\n  is called as `callback(response, context)`, where `response` is the latest\n  received message, and must return a result. \n  The returned result is send to the connected peer.\n  When the callback returns a Promise, the value returned when the promise\n  resolves will be send to the connected peer.\n\n- `babble.then(next: Block | function) : Block`  \n  Create a flow starting with given block. When a callback function is provided,\n  the function is wrapped into a `Then` block. The provided callback function\n  is called as `callback(response, context)`, where `response` is the latest\n  received message, and must return a result. \n  When the callback returns a promise, babble will wait with execution of the \n  next block until the promise is resolved. The result returned by the callback\n  is passed to the next block in the chain.\n\n\n- `babble.unbabblify(actor: Object) : Object`  \n  Unbabblify an actor. Returns the unbabblified actor.\n\nBabble contains the following prototypes. These prototypes are normally\ninstantiated via the above mentioned factory functions.\n\n- `babble.Babbler`\n- `babble.block.Block`\n- `babble.block.Decision`\n- `babble.block.IIf`\n- `babble.block.Listen`\n- `babble.block.Tell`\n- `babble.block.Then`\n\n### Babbler\n\nA babbler is created via the factory function `babble.babbler(id: String)`.\nAfter creation, a babbler is automatically connected to the default (local) \nmessage bus. The connection can replaced with another message bus using the\nfunction `Babbler.connect(bus)`.\n\nA babbler has the following functions:\n\n- `ask(to: String, message: * | Function [, callback: Function]) : Block`  \n  This is equivalent of doing `tell(to, message).listen([callback])`.\n  Other blocks can be chained to the returned block.\n\n- `connect([bus: Object]) : Promise.<Babbler>`  \n  Connect to a message bus. Babble comes with interfaces to support various\n  message buses: `pubnub`, `pubsub-js`, and `default`. These interfaces are\n  available in the `babble.messagebus` namespace.  If parameter `bus` is\n  not provided, babble uses the `default` message bus, which works locally.\n  A specific message bus interface can be specified like:\n\n  ```js\n  babbler.connect(babble.messagebus['pubnub'])\n      .then(function (babbler) {\n        // connected\n      });\n  ```\n  \n  The connect function returns a promise which resolves with the babbler itself\n  when the connection is ready.\n  \n  See section [Message bus](#message-bus) for documentation on the interface\n  of a message bus.\n\n- `disconnect()`  \n  Disconnect from the connected message bus.\n\n- `listen([condition: Function | RegExp | * [, callback: Function]]) : Block`  \n  Listen for incoming messages and start the conversation flow. \n  Other blocks can be chained to the returned block.\n\n  Providing a condition will only start the flow when condition is met,\n  this is equivalent of doing `listen().iif(condition)`.\n  \n  Providing a callback function is equivalent of doing either \n  `listen(message).then(callback)` or `listen().iif(message).then(callback)`.\n  The callback is invoked as `callback(message, context)`, and must return\n  either a result or a Promise resolving with a result. The result will be \n  passed to the next block in the chain.\n\n- `listenOnce([condition: Function | RegExp | * [, callback: Function]]) : Block`  \n  Equal to `listen`, except that the listener is removed as soon as a message\n  is received matching listeners condition, i.e. the listener is executed only\n  once.\n\n- `send(to: String, message: *)`  \n  Send a message to another peer.\n\n- `tell(to: String, message: Function | *)`  \n  Send a notification to another peer.\n  `message` can be a static value or a callback function. When `message` is\n  a function, it is invoked as `callback(message, context)`, and must return\n  either a result or a Promise resolving with a result. The result will be \n  sent to the other peer, and will be passed to the next block in the chain.\n\n### Block\n\nBlocks can be created via the factory functions available in `babble`\n(`tell`, `iif`, `decide`, `then`, `listen`), or in a Babbler (`listen`, `tell`,\n`ask`). Blocks can be chained together, resulting in a control flow. The results\nreturned by blocks are used as input argument for the next block in the chain.\n\nA `Block` has the following functions:\n\n- `ask(message: * [, callback]) : Block`  \n  Append a `Tell` and `Listen` block to the control flow. \n  Parameter `message` can be a callback function or an object or value. \n\n- `decide([decision: function, ] choices: Object<String, Block>) : Block`  \n  Append a `Decision` block to the control flow. \n\n- `iif(condition: function | RegExp | * [, trueBlock : Block] [, falseBlock : Block]) : Block`  \n  Append an `IIf` block to the control flow. \n  When the condition evaluates `true`, `trueBlock` is executed. \n  If no `trueBlock` is provided, the next block in the chain will be executed.\n  When the condition evaluates `true`, `falseBlock` is executed.\n\n- `listen([callback: Function]) : Block`  \n  Append a `Listen` block to the control flow. Providing a callback function is \n  equivalent of doing `listen().then(callback)`.\n\n- `tell(message: * | Function) : Block`  \n  Append a `Tell` block to the control flow. Parameter `message` can be callback\n  function or an object or value.\n\n- `then(block : Block | function) : Block`  \n  Append an arbitrary block to the control flow. When a callback function is\n  provided, it is wrapped into a `Then` block and added to the chain.\n\n\n## Message bus\n\nBabblers talk to each other via a message bus. This can be any message bus \nimplementation. Babble comes with support for two message buses: a local\nmessage bus and [pubnub](http://www.pubnub.com/).\n\n### Interface\n\nThe function `Babbler.connect(bus)` accepts a message bus interface. This\ninterface must be an Object with the following functions:\n\n- `connect(params: Object) : string`  \n  The function `connect` will be called by the Babbler with an object having \n  the following parameters: \n\n  - `id` the id of the babbler itself.\n  - `message` the callback function to deliver messages for this babbler.\n    This function must be invoked as `message(msg : *)`.\n  - `callback` an optional callback function which is invoked when the \n    connection is established.\n\n  The `connect` function must return a token which can be used to disconnect\n  again.\n\n- `disconnect(token: string)`  \n  Disconnect from a message bus. `token` is the token returned by the `connect`\n  function.\n\n- `send(id: string, message: *)`  \n   Send a message to a babbler.\n\n### Protocol\n\nThe messages sent between babblers are JSON objects having the following properties:\n\n- `id: string`  \n  A unique identifier for the conversation, typically a uuid. \n  This id is generated by the initiator of a conversation, and is sent with\n  every message between the two babblers during the conversation.\n- `from: string`  \n  The id of the sender.\n- `to: string`  \n  The id of the receiver.\n- `message: *`  \n  The message contents. This is a (serializable) JSON object (often a string).\n\nExample:\n\n```json\n{\n  \"id\": \"547d1840-2142-11e4-8c21-0800200c9a66\",\n  \"from\": \"babbler1\",\n  \"to\": \"babbler2\",\n  \"message\": \"Hello babbler!\"\n}\n```\n\n\n## Build\n\nBabble can be build for use in the browser. This is done using the tools\nbrowserify and uglify. First install all project dependencies:\n\n    npm install\n\nTo build the library, run:\n\n    npm run build\n\nThis generates the files `./dist/babble.js`, `./dist/babble.min.js`, and \n`./dist/babble.min.map`.\n\n\n## Test\n\nTo execute tests for the library, install the project dependencies once:\n\n    npm install\n\nThen, the tests can be executed:\n\n    npm test\n\n\n# Roadmap\n\n- Implement error handling and timeout conditions.\n- Store message history in the context.\n- Implement conversations with multiple peers at the same time.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/josdejong/babble.git"
  },
  "scripts": {
    "build": "browserify ./index.js -o ./dist/babble.js -s babble -x pubnub; uglifyjs ./dist/babble.js --output ./dist/babble.min.js --source-map ./dist/babble.map --source-map-url ./babble.min.map --compress --mangle --comments",
    "test": "mocha test --recursive --reporter spec"
  },
  "version": "0.11.0"
}
